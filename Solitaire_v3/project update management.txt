suddat suOBJECT ID AND DESTINATION 
841 +

note... when the card is dropped you can use the id of the drop pile to push the card  to the associated 'tracking' subarray. 

But you also need to 'pop' the card (or cards) out of the destination array. so maybe have an object representing the card as below: 

{
card:
origin:
destination:
array_index:
}


some considerations: 

when multiple cards are transferred, just the first card in the selected group of cards is registered.  which means that: 
a) all of the cards accompanying the first card need to be pushed to the array, and all of them need to have their objects updated

b) all of the card objects in the origin subarray need to be popped out of the  arry; I suppose splice could be used for that ; you'll need the index of the index of the first card to use array.splice(index, -1) which will remove everything, first card object included, up to the end of the array. 

c) you need a record of all the cards that are dropped, and for a way to push 'all' of them to the array associated with the destination pile. 


Waht you could do is map through the origin array for the id of the first selected card, and if the card is not in the last position of the array, then record the firwst card and other cards into the temporary array, then you can place them all into the destination array. 

1285 gives the origin pile. 

879 gives desintation pile

1293 gives card id. 


when doing a transfer of the moved multiple cards.  You'll need to get the value of all of the cards 'above' the first picked cards, and, using the number of cards transferred value in the object, the values of the other cards by mapping through the destination, finding the position of the first card, and looping through the childnodes of the destination pile, creating a new object for each childnode found from the list of children following the first card; 

all you need is the id of the card because all other details on their object, origin destination are the same as that of the first card. Those objects can then be pushed (after the first card object) to the array representing the destination pile. for the initial object, only the 'primary_card' property (which is an objectd containing card value, origin and destination) needs to be pushed to the drop pile array;  The other objects created can just be a copy of that, but with their own unique card value being used instead of the first card value. 

then it's just a matter of using the origin name to select the correct drop pile array, search through it for the object that has the first card's value, and using the index to splice through to the end of the array to remove the card and all of those that follow it in the array. 

the 'number of cards' transferred can be used to dictate what kind of function operates; so for single card drops, the card just needs to be popped from the origin drop pile array and pushed to the destination drop pile array.  Multiple card drops will be handled as in the above paragraphs. 

FROM WASTE PILE TO FOUNDATION PILE. 

This also needs to be handled since, I don't think this is being registered at the moment and might be the principal cause for inaccurate information about where cards are. 

once everything is handled then it would be a good idea to console log the arrays to make sure they are representing card positions correctly, and once that is confirmed, then, in the case of a solvable scenario, the solve function can use the arrays and carry out a solve since, hopefully, all cards should be showing the correct positions. 


NO DESTINATION: 

if the last element of the multiple cards array has no destination, it means that the card was selected but never dropped onto a different destination, which is not a problem because the object never gets to the place where the destination can be recorded (that's why it has no destination because that's where the destination is inserted into the object) 


You can tell if the card just droppedx on the foundation pile is from the waste pile; basically if the card value matches the zero position value of the wasteArr array, then the card's origin is the the waste pile. 
so, we can have the condition inside the 

so, if the card comes from the waste pile there's no need to remove it from the waste array, that will be handled, but anyway, waste array and remain array are not used when in the 'solve' process so their positional accuracy isn't a factor. 

If a card is selected but not moved then it won't be registered as dropped, so now it's just a question of writing the function to place dropped cards into destination array and to remove them from origin array. and it's a simple matter of checking how many cards were moved to decide which function needs to be executed. 

Note, that, since wastepile cards can only be draged one by one, you only need to push the card object to the destination so there are three functions,

a) functions handling cards moved from the waste pile to drop piles or foundation piles
b) functions handling movement of one card to from


a) push object to destination array 
b) push object to destination array and pop origin array
c) 
1. get index of first selected card object in origin array
2. push that, and following objects, up to the last object to the destination drop pile array, 
3. splice the same elements from the origin drop pile array. 


NOT FINISHED YET.  

There's an issue with moving files from foundation piles to drop pile.. wrong card is being registered. 

the reason why the wrong card is being registered is because the last element of the recrods array is being logged to the console. This happens because, accidentally, we are meeting the condition in the else part of the if/else statement.  The if condition is that the card value was in the zero position of the waste array, in other words, the card came from the waste pile, but this won't be the case for cards coming from the foundation piles, so, because there is no other condition set, those card drops fall into the else category of cards 'not' originating int he waste pile.  What needs to be done is for there to be another condition set, such that if the value of the dropped card does not correspond to the value of the last card in the records array and did not come from the waste pile, then it must have originated in the foundation pile...  NOt sure if this is bomb proof but will test it. 

The above seems to be working; and you can move cards back and forth between the same two positions and the correct information will appear in the last object on the records array.  NOW WE CAN PROCEED WITH POPULATING THE ARRAYS to record the positions of all cards.  



JUST A THOUGHT ABOUT A BACK BUTTON. 
It seems plausible that the record kept in the tracking array can be used to calculate reversal of previous moves, because the order of the objects in the array is the order in which cards were moved from one place to another; and since we have both destination and origin, then the array can be used to move a card from destination back to origing, and the preceding card can move from its destination back to its origin and so forth - you should be able to go all the way back to the beginning of the game.   you could also integrate a replay this game functionality where the original state is saved and the cards are returned to that state... so much can be done.


ISSUE - if card drop fails, the card's tracking object still gets pushed to the breadcrumb array. I noticed that the plain/text id in the data transfer is still recorded when the card is not dropped. It might be happening because the drop function is only allowed to continue if the ID property is extracted from the gragged card prior to drop. 

Since the presence of the ID is independed of drop status (success or failure), it's not possible to use the id (or its absence) to decide whether to push a card object to the breadcrumb array.  So, below, I'm going to look for the parts of the code that report 'illegal' moves, because it's those moves that prevent the card drop, and when they occur, the card's object is still pushed to the breadcrumb array. So that might be a good place to pop the last element from 'breadcrumb' or perhaps a better solution would be to remove the object from the temporary array, and then have a condition that only allows the breadcrumb push 'if' the array is in a specific state.  

I think that might require emptying the tempoarary array after the previous push, so that there is only ever 'one' temporary object in the array, so then, if an illegal move is made, then, prior to the drop function being executed, the temporary array is emptied, and then at the beginning of the drop() function where the temporary object is pushed to the breadcrumb array, use an if/else that will only execute breadcrumbArray.push(temporary_object), if the array is not empty.  

CHANGE IN IDEA. 
Found that the best place to push the object from temporary array to the breadcrumb array is the moment when the card being assessed successfully meets the conditions for dropping to a pile; just before the card's HTML object is sent to the cardType function for appending to the pile, that's the place I've decided to push to breadcrumb.  There's one caveat though.  Files passing the conditions may also come from the waste pile, and in that case, there was never a temporary tracking object in the temporary array.  This is explained in the code on line 396 in the JS file.  Essentially cards don't recieve tracking until they have been played, so cards not yet moved from their original positions don't need a breadcrumb position, and neither do cards in the waste pile because they are not played until they are dropped; then the tracking begins. Waste card objects are created for tracking when a dropped card is recognized as having originated in the waste pile; and then the tracking object is pushed directly to the breadcrumb array. 

So, with this caveat in mind, prior to pushing a dropped card to the breadcrumb array, there's a check to see if the temporary is not empty; if it is, then there's nothing to push to the breadcrumb array, since that will be done later when the dropped card is seen to have originated in the waste pile.  This solves another issue I had recently where empty values were being pushed to the breadcrumb array. This seems to have solved the above isssue of cards getting pushed to the breadcrumb array although the drop had been rejected.  I still have to check whether altering a tracking object affects the properties of other versions of the object pushed earlier to the breadcrumb array.  Once that issue is solved, then I can rewrite the code for auto-completing the game, and then it's onto the manipulation of HTML elements with animations to render both back movements and game auto complete, and then that will be the first full iteration complete

I can then think about making things more difficult by dropping 3 cards at a time and also displaying the wast cards as a cascade to aid the player in making decisions. Much more like the classic version of the game for PC. 

Looking at the breadcrumb pile, it seems as though the history is in correct order.  What I might have to do is actually record a game and then follow the history to see what happens, before trying to code the movements, or perhaps it's better to have a rudimentary reverse system where you take the card in the breadcrumb, and to reverse its movement, just use remove child on the current destination and append child on the origin. In fact, I think it's just a question of doing originPile.append(destinationPile), which is how it worked in another game  - I can't remember which one now. Then you'd have to reverse rearrange the tracking arrays to represent the new configuration. 

NEXT CHALLENGE - create the history
There was an issue with using the back button; how do you know whether the card exposed by the movement of the current card was face up or face down? This was a challenge to figure out.  I thought of checking the 'draggable' attribute immediately after the card movement, but face down cards flip and the attribute is set to draggable true; so, when undoing the move, whether the card was flipped by the move or not, it's draggable attribute value will be true. 

I also thought about using the fact that, if the remaining top card was incompatible with the moved card, i.e. their true values were not consecutive or the suits were not of different  colours, the moved card could not have been sitting on the faceup remaining card:

 - remaining card incompatibility with the moved card indicates the flip must have happened post-move, because the incompatible remaining card is faceup. 

- remaining card COMPATIBILITY with the moved card indicates two things, 
a) that the remaining card could have been lying 'faceup' beneath the moved card or, 
b) that the remaining card could have been lying facedown beneath the moved card, 

A compatible remaining card does not guarantee that a flip happened when the card movement happened. So card compatibility/incompatibility together does cannot guarantee what the status of the remaining card was prior to the move. 

SOLUTION: 
Decided to add two new properties to the tracking object for each card: 
when_flipped, and when_moved. 
Then, using the length of the breadcrumb array which records when moves occured, in chronological order, when a card is moved and its tracking object is pushed to the breadcrumb array, the length of the array indicates which move that corresponds to, so the when_moved property on the object takes that value.  

if the remaining card is flipped, then we seek out its tracking object and write the same number to the when_flipped property on the object.  So when the undo function is executed, it's just a matter of checking if the when_moved property on the card we intend to execute a reverse move on, matches the when_flipped number of the remaining card which the move card will sit back onto.  if the numbers match, then the remain card was flipped when the card (which is now returning) was moved so the remain card can be turned over again, and if they don't match then nothing needs to happen.  

The when_flipped property is given independent of the when moved property. For example, all end cards of the drop piles have their when_flipped properties assigned a value of zero at the time of distribution, because they are flipped prior to any moves. And I've decided that the function that detects when a remain card is facedown and flips it, is the best place to assign the when_flipped property on the cards object the value that corresponds to the length of the breadcrumb array, i.e. which move in the sequence of all moves caused the card to flip. 






If this works then I'll move on to rewriting the function for the auto-solve (SOLVED)
after than I can deal with the actual movements of elements to correspond with the tracking object changes,
then, after that is working, I can learn how to do automatic animations to add REALISM to undo and auto-solve features. 

WORKING BACK BUTTON FUNCTIONS
Firstly, moving single and multiple cards from pile to pile, at least drop pile to drop pile seems to be working. 

ISSUES: 
dropping foundation cards down to drop piles is not recording the drop in the breadcrumb. The card goes to the breadcrumb array, but the details are incorrect, AND, the card doesn't move from the origin tracking array to the destination tracking array. 

